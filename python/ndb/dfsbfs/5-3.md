# 5-3. 음료수 얼려 먹기

- 0은 뚫려 있는 부분, 1은 막힌 부분이다.
- 0에 음료를 채웠을 때 나올 수 있는 아이스크림 수를 구한다.

## 제출 답안

- 뭉쳐있는 아이스크림은 한 점에서 가까운 노드부터 탐색하는 것과 같다고 생각해서 BFS로 접근했다.
- BFS 기본 알고리즘은 구현할 수 있지만 응용 안돼서 풀지 못했다.

## 모범 답안

```python
n, m = 15, 14

graph = [
    [0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0],
    [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0],
    [1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0],
    [1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0],
    [1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0],
    [1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1],
    [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1],
    [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0],
    [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1],
    [1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
]


def dfs(x, y):
    # 맵의 범위를 벗어나면 빠져나간다.
    if x < 0 or x >= n or y < 0 or y >= m:
        return False
    if graph[x][y] == 0:
        graph[x][y] = 1
        # 단순히 방문 처리를 하기 위한 목적으로
        # 상, 하, 좌, 우에 대해 호출한다.
        dfs(x - 1, y)
        dfs(x + 1, y)
        dfs(x, y - 1)
        dfs(x, y + 1)
        return True
    return False


result = 0
for i in range(n):
    for j in range(m):
        if dfs(i, j):
            result += 1

print(result)
```

- 각 노드의 상하좌우를 방문하면서 처리한다.
- 기본 구현처럼 graph, visited가 있어야 한다는 생각에서 벗어나야겠다.