# 3-4. 1이 될 때까지

- n과 k가 주어질 때
    - N - 1 하거나
    - N / K 한다. (나누어 떨어질 때만)
- 둘 중 하나를 반복적으로 선택해 N == 1이 되도록 만드는 횟수를 구한다.

## 제출 답안

```python
n = 23
k = 2
count = 0

while n != 1:
    if n % k == 0:
        n /= k
        count += 1
    else:
        n = (n - 1) / k
        count += 2

print(count)
```

- 나누어 떨어지면 나눈다.
- 나누어 떨어지지 않으면 n-1한 뒤 n을 k로 나누는 두 과정을 하나로 묶는다.

## 모범 답안

```python
n, k = map(int, input().split())

result = 0

while True:
    # k로 나누어 떨어지는 수를 임의로 구한다.
    target = (n // k) * k
    # 1을 빼는 연산을 몇 번을 수행하게 될지 구한다.
    result += n - target
    # 이제 k로 나누어 떨어지는 것만 고려했을 때 몇 번을 해야할지 구한다.
    n = target

    # n이 k보다 작을 때(더 나눌 수 없을 때) 반복문을 나간다.
    if n < k:
        break

    # k로 나누는 연산 횟수를 반복해서 구한다.
    result += 1
    # 다시 k로 나눈 몫을 구해 다음 반복문으로 간다.
    n //= k

# n < k인데도 n이 1보다 크다면 이 남은 수에 대해 1씩 빼는 연산을 해야하므로 그 횟수만큼 더한다.
result += (n - 1)

print(result)
```

- 키 포인트는 `최대한 많이 나눠서 격차를 빨리 줄이기` 이다.
    - 이 아이디어를 생각은 했으나 어떻게 구현해야 할지 떠오르지 않았다.