# 6-1. 기준에 따라 데이터를 정렬

## 정렬

- 데이터를 특정한 기준에 따라 순서대로 나열하는 것
- 이진 탐색의 전처리 과정이니 제대로 이해해야 한다.

## 선택 정렬

- 매번 가장 작은 것을 선택하는 원시적인 방법
- 데이터가 무작위로 있을 때 가장 작은 데이터를 맨 앞과 바꾸고, 그 다음 작은 것을 앞에서 두 번째와 바꾸는 과정을 반복한다.

```python
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(len(array)):
    # 일단 제일 작은 값의 인덱스를 설정해두고
    min_index = i

    # 다음 인덱스부터 차례로 돌면서 더 작은 게 있는지 확인한다.
    for j in range(i + 1, len(array)):
        if array[min_index] > array[j]:
            # 있다면 새 인덱스로 교체한다.
            min_index = j
    # 최종적으로 제일 작은 값을 갖고 있는 인덱스와 교체한다.
    array[i], array[min_index] = array[min_index], array[i]
```

### 시간 복잡도

```text
N + (N - 1) + (N - 2) + ... + 2
= N * (N - 1)
= (N^2 + N) / 2
```

- O(N^2)
    - N-1번 만큼 가장 작은 수를 찾아 맨 앞으로 보낸다.
    - 매번 가장 작은 수를 찾기 위해 비교 연산을 한다.
- 간단히는 2중 반복문이 사용되었기 때문에 O(N^2)이라고 할 수 있다.
- 데이터가 10,000개 이상이면 급격히 느려진다.
- 다른 알고리즘에 비해 비효율적이다.

## 삽입 정렬

- 필요할 때만 적절한 위치로 데이터를 삽입한다.
- 그 앞가지의 데이터는 이미 정렬되어 있다고 가정한다.

```python
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(1, len(array)):
    # 현재 기준에서 이미 정렬된 앞에 있는 숫자와 비교하면서 적절한 위치를 찾는다. 
    for j in range(i, 0, -1):
        if array[j] < array[j - 1]:
            array[j], array[j - 1] = array[j - 1], array[j]
        else:
            break
```

### 시간 복잡도

- O(N^2)
- 반복문이 2번 중첩된다.
- 데이터가 거의 정렬되어 있다면 O(N)이다.

## 퀵 정렬

- 피벗보다 큰 수와 작은 수를 교환한 뒤 리스트르 반으로 나눈다.
- 나눈 리스트에서 각각 정렬을 다시 수행한다.
- 지귀 함수와 동작 원리가 같다.
    - 종료 조건은 데이터 개수가 1개인 경우다.

```python
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]


def quick_sort(array, start, end):
    # 데이터 개수가 1이거나 비정상적이면 종료한다.
    if start >= end:
        return

    # 맨 첫번째 값을 피벗으로 정한다.
    pivot = start
    # 피벗 다음부터 비교한다.
    left = start + 1
    right = end

    # 왼쪽 인덱스가 오른쪽 인덱스를 넘지 않을 때까지
    # 즉, 서로 엇갈리지 않을 때까지 반복한다.
    while left <= right:
        # 왼쪽 인덱스가 범위 내에 있으면서 값이 피벗보다 작거나 같다면
        while left <= end and array[left] <= array[pivot]:
            # 계속 뒤로 이동한다.
            left += 1
        # 오른쪽 인덱스가 범위 내에 있으면서 값이 피벗보다 크거나 같다면
        while right > start and array[right] >= array[pivot]:
            # 계속 앞으로 이동한다.
            right -= 1
        # 서로 인덱스가 엇갈렸다면
        if left > right:
            # 작은 값이 있는 오른쪽과 피벗을 교체한다.
            array[right], array[pivot] = array[pivot], array[right]
        # 엇갈리지 않았다면
        else:
            # 작은 값과 큰 값을 교체한다. 
            array[left], array[right] = array[right], array[left]
    # 분할된 리스트에 대해 다시 반복한다.
    quick_sort(array, start, right - 1)
    quick_sort(array, right + 1, end)
```

### 시간 복잡도

- O(NlogN)
- 분할이 수행되는 횟수가 기하급수적으로 감소한다.
- 데이터가 무작위로 많을 수록 압도적으로 빠르다.
- 데이터가 이미 정렬된 경우 O(N^2)이다.

## 계수 정렬

- 데이터 크기 범위가 제한되어 정수로 표현할 수 있을 때 사용한다.
    - 크기가 크더라도 제한되어 있따면 매우 빠르다.
- 데이터 차이가 너무 크면 사용할 수 없다.
- 리스트에 각 데이터가 몇 번 등장했는지 횟수를 기록한다.
    - 리스트가 정렬된 데이터 그 자체가 된다.

```python
array = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]

# 모든 범위를 포함하는 리스트를 만든다. 값은 0으로 초기화한다.
count = [0] * (max(array) + 1)

for i in range(len(array)):
    # 나온 횟수만큼 인덱스의 값을 증가시킨다.
    count[array[i]] += 1
```

### 시간 복잡도

- O(N+K)
    - 앞에서부터 N개의 데이터를 하나씩 확인하면서 인덱스 값을 1씩 증가시킨다.
    - 최댓값 K만큼 반복하며 인덱스에 해당하는 값을 확인한다.
- 범위만 한정되어 있다면 항상 빠르게 동작한다.

### 공간 복잡도

- 100만 개의 범위에서 데이터가 0과 999,999 2개만 존재한다면 리스트 공간이 낭비된다.
- 동일한 값을 여러 개 가질 때 적합하다.

## 파이썬의 정렬 라이브러리

### sorted()

```python
sorted(array)
```

- 병합 정렬 기반
    - 최악의 경우에도 O(NlogN)을 보장한다.
- 정렬된 결과 출력
    - 어떤 자료형이든 리스트로 반환한다.

### sort()

```python
array.sort()
```

- 내부 원소가 바로 정렬된다.

### key 활용

```python
array = [('바나나', 2), ('사과', 5), ('당근', 3)]


def setting(data):
    return data[1]


result = sorted(array, key=setting)
# [('바나나', 2), ('당근', 3), ('사과', 5)]
```

- sorted(), sort()는 key 매개변수를 입력으로 받을 수 있다.
    - key
        - 정렬의 기준이 되는 함수
        - 람다 사용 가능

### 시간 복잡도

- 정렬 라이브러리는 최악의 경우에도 O(NlogN)을 보장한다.
- 단순 정렬이면 기본 라이브러리를 사요한다.
- 데이터 범위가 한정되어 있고 더 빠르게 동작해야 하면 계수 정렬을 사용한다.

### 정렬 알고리즘 문제 유형

- 정렬 라이브러리로 풀 수 있는 문제
- 정렬 알고리즘의 원리를 물어보는 문제
    - 선택 정렬, 삽입 정렬, 퀵 정렬 등의 원리 숙지
- 더 빠른 정렬이 필요한 문제
    - 계수 정렬 등 다른 알고리즘을 이용하거나 기존 알고리즘의 구조 개선 필요